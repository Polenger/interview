**PQ(笔试题)，Q(面试提问)**

## JavaSE基础：

##### Java 包含哪些基本数据类型及其包装类？

Java共有8种基本数据类型，分别是byte, short, int, long, float, double ,char , boolean. 对应的包装类型有Byte, Short, Integer, Long，Double, Float, Character, Boolean

要讲包装类型转换成基本类型时，则调用包装类对象的intValue(), shortValue()，xxxValue()等方法.

可以这样回答：

> Java一种提供8种基本数据类型及其包装类，分别是byte和Byte...

##### **如何理解Java 的自动装箱和拆箱？**

##### **请简述Java的main 方法？**

main 方法是Java程序的执行入口，它是一个定义在类中的、公开的、静态的、无返回值的、参数为一个字符串数组的方法，它的参数args与执行参数一一对应。

##### **== 和equal 方法的含义。**

==是比较两者的引用地址，equal 比较两者的值。

回答思路： 先说两个有相同的含义，在从基本类型的比较和引用类型的比较详述。

equal 方法和 == 两者都可以表示**相等**的意思，但是两者相等的含义却有所不同。

== 运用在基本数据类型时，通过比较他们实际的值来判断是否相等；在比较引用类型是，则是比较引用对象的地址是否相等，也就是是否指向同一个对象。

equal 方法是Object类的方法，则所有Java 类都会有的方法，该方法可以被重写。采用自定义方式来判断两者是否相等。对于String类来说，它的equal方法用于比较字符串的字符序列是否完全相同。

##### **&与&& 区别：**

一个表示位运算， 两个表示逻辑运算符。

##### **Java 的三大特性(相关点)**

**Java 的继承：**

在Java 中采用单继承机制，使用extends关键，表示扩展的意思，通过继承的方式，子类可以用过父类非私有成员以外所有成员，从而达到代码复用的目的。在继承过程中，可以通过方法覆盖来实现多态，让子类拥有自己独特的方法实现形式。

**Java的多态：**

多态从字面意思来理解是多种状态，多种形态。本质上是发送消息给某个对象，让该对象自行决定响应何种行为。通过将子类对象引用赋值给父类对象引用变量来实现动态方法调用。

**抽象类和接口：**

抽象类是一种功能不全的类，接口知识一个抽象方法声明和静态不能被修改的数据集合，两者都不能直接实例化，从某种意义上来说，接口是一种特殊形式的抽象，在Java中，抽象类表示一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

##### 内部类： **静态内部类、成员内部类、局部内部类、匿名内部类。**

int 4字节，保存在栈空间里。用于算数运算。参数传递的时候，采用值传递。

Integer是int的包装类型，本质上是一个类，它的创建会在堆内存种开辟一个新的空间。其含义表示一个整型数字，但是算数运算符不能直接操作它。

##### **数据类型： 整数类型+ 实数类型**

pQ: 商业情景下，进行转账交易，需要用到**BigDecimal**的构造方法。

add()、subtract、multiply、divide

#### **String类型的相关知识：**

Q: String 是基本数据类类型吗？

不是， String属于final类型的，因此不可以继承这个类，不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类或者StringBuilder类

简介：属于一个特殊的类，可以通过双引号创建对象，字符串之间可以用“+”操作，不能被继承。

1、采用双引号会直接创建一个String对象，并返回这个对象的引用实例。

对象池

从JDK1.5开始，java虚拟机在启动的时候就会实例化9个对象池。这9个对象池分别用来存储8种基本类型的包装类型和String类型，为了就是提高效率问题。

> 答： 对象池的存在意义是为了避免频繁的创建和销毁对象从而影响系统的性能。当JVM在运行用双引号引起来一个字符串的代码的时候，会到String的对象池中检查是否有一个字符序列相同的对象。若有，就取出现有对象。若无，则往对象池中添加一个对象，并返回。俗称入池。

缓冲表示线程不安全，效率高。构建线程安全，但是效率低。

**字符串操作：**

1）字符串反转

思路一： 将字符串用toCharArray方法转换成字符数组，当然重新排列。

思路二：将字符串生成stringbuffer对象，调用其reverse方法

2）字符串编码问题：

#### 集合：

一些基础知识：

1、Java 的集合类主要是由两个接口派生出来： collection 和Map, Collection 和Map 是Java 集合框架的根接口。接口包括一些接口和实现类。

在Collection类的子类有Set，表示无序集合，元素不可重复， Queue 队列， List 有序集合，元素可重复。（Set和List 接口是Collection 派生的两个子接口，Queue是Java 提供的队列实现，类似于List）。Map 实现类用于保存具有映射关系的数据（Key-value）

2、**Set、List 和Map** 可以看做集合的三大类

List 集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。

Set 集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问。（也是Set 集合里元素不允许重复的原因）。

Map集合中保存Key-value对（键值对）形式的元素，访问只能根据每项元素的key 来访问其value。



**Q: 集合类之间的继承关系？**

Q：数据结构了解的怎么样？ArrayList和LinkedList采用什么数据结构？

**Q: HashMap的存储机制（重点）**

**Q：HashMap键值对是如何存放key和value， put 方法，get方法？(2-3min)**

A: HashMap底层是采用**hash数组**和**单向链表**实现的。当调用put方法时，首先计算key的hashcode值，定位到合适的数组索引，然后再该索引上的单向链表进行循环遍历，用equals方法进行比较key是否存在，两者比较结果是true，表示存在，就用新的value覆盖原来的value，返回的结果是false，表示不存在，则插入到单向链表的头部。

HashMap有两个重要属性是表示容量capacity（容量） 和load foctor(负载因子），默认值是16 和0.75，当容器中的元素大于 capacity * loadfactor时，容器会进行扩容resize为2n。在初始化Hashmap时可以capacity和loadfactor的值进行修改，通常对于负载因子，建议值为0.75，属于经验值，通常不会进行修改。只有初始容量capacity会导致频繁的扩容行为，属于耗资源的操作。所以一般要修改估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，来防止频繁的resize操作，从而影响性能。

引申问题： **HashMap的工作原理怎么样（底层是如何实现的）**？

引申问题：为什么是插入到单向链表的头部，而不是向后追加。问题涉及到线程安全的一些问题。

**简单问题：**

**什么是Hashmap，为什么要考虑用它？---> 应该是考虑用它有什么好处吧**

Hashmap的一些特性： Hashmap可以接受null作为键或者值，而hashtable不行；Hashmap非线程安全的，效率高； hashtable是**线程安全，效率低。**

**Hashmap的工作原理？ hashmap的get 方法的实现原理？**

Hashmap 是基于**散列法（hashing）**的原理，使用**put(key,value) 方法**存储对象到Hashmap中，使用get方法，根据key值从Hashmap中获取对象。当我们给put方法传递键值对时，我们首先对键调用**hashCode**方法，返回Hashcode用于找到bucket位置来存储Entry对象。hashmap中是在bucket中存储对象和值对象 ，作为Map.Entry。

> HashMap 是基于散列法的原理，使用put 方法存储对象到HashMap中，其get方法，是根据key值从Hashmap中获取对象。当我们给put方法传递键值对是，首先对键调用hashcode方法，返回hashcode用于找到bucket位置来存储Entry对象，hashmap中是在bucket中存储对象和值，作为Map.Entry.

**追问: 当两个对象的hashcode 相同会发生什么？**

这两个对象的Hashcode 会被存储在同一bucket位置上的LinkedList中，通过键对象的equals 方法来找到对应觉得键值对。

**ZQ: 当前项目有没有用到hashmap 呢？**

由于Hashmap的好处多，通常我都是用它作为一种**缓存机制**。但是出于线程安全问题的话，可能也会用到concurrentHashmap 来保证线程安全。

**HashMap问题相关知识点的总结：**

1、hashing（散列法）的概念

2、HashMap中解决碰撞的方法

3、equals 方法和hashCode方法的应用，以及他们在HashMap中的重要性

4、不可变对象的好处

5、HashMap多线程的条件竞争

6、重新调整HashMap的大小。



Q: 说说集合体系。ArrayList 和LinkList的区别和底层实现？项目中使用到哪些，为什么要这样用呢？

集合的架构：

list, set，map 三个主要的



#### 多线程：

Q:  创建线程的两个方式：

 继承Thread类，重写run方法或者实现Runable接口，重写run方法。

Q: 多线程的概念，多线程实现需要注意什么问题？ 死锁问题。

相互等待对方资源的释放。

1、如何启动一个线程（怎么用）

线程类通过继承Thread类或者实现Runnable接口，并且将线程要执行的代码写在run方法中。如何启动一个线程，本质上就是并发执行run方法中的代码。

PQ(大题)：打印当前线程名字，每隔300ms打印一次，共打印10次。

```java
@Override
public void run() {
    try {
        sleep(300);
        synchronized (getClass()){
            for (int i = 0; i <10 ; i++) {
                System.out.println(currentThread().getName());
            }
            System.out.println("--------------------------");
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

#### 内部类：



#### 接口：

网络模型：

服务器端：

(1) 创建一个服务器端的socket，指定一个端口号。

(2) 开始监听来自客户端的请求

(3)获得输出流或输入流

(4)调用输入流、输出流的read或者write方法，进行数据传输

(5) 释放资源，关闭输出流或者输入流、socket连接和serverSocket 连接对象。



URL: 表示网络上某种固定的资源（一个超链接）



### JavaWeb 知识：

JavaScript的知识：



JSP的内置对象有哪些：



ISO-8859-1编码问题，为什么会有这个乱码问题（HTTP协议，get提交），如何解决

常见的Http状态码：

411 (Length Required/需要数据长度)

411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求(假设为带有附件的POST请求)，除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。

Jquery如何选择一个元素

如何实现Ajax 异步请求？



#### **网络协议：**

协议是定义计算机如何通信的一套规则： 地址格式， 数据如何分包。Http 协议定义有很多不同的协议。





#### Http请求协议：

1、 Http 响应的结构是怎么样的？

Http 响应由三部分组成： 响应码（status Code）状态码： 描述响应的状态，可以用来检查是否成功的完成了请求。

Http 头部（Http Header）: 包含了更多关于响应的信息。比如： 头部可以指定认为响应过期的过期日期，或者指定用来给用户安全的传输实体内容的编码格式。

主体：body: 包含了响应的内容，可以包含Html 代码，图片等。

**状态码：**

200 发送和响应成功。

400 错误请求，语法错误。

401 未授权

403 禁止访问

扩展： 403.1 禁止执行访问

500 服务器内部问题。



WebSocket 协议：



## Cookie和Session的的区别

1. 由于HTTP协议是**无状态的**协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的使用场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了**特定的Session**，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在**内存**的，使用一些**缓存服务**比如Memcached之类的来放 Session。
2. 思考一下服务端如何识别**特定的客户**？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做**URL重写**的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。







### 数据库方面：

Q: 数据库的索引

A： 普通索引、唯一索引、主键索引(一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引)。

**数据库的功能在于对数据如何存储和检索。**

如何理解JDBC(java 数据库连接)，使用统一的SQL语句进行增删查改的操作。JDBC技术支持数据库连接池技术。

知识点： SQL 属于结构化查询语言，专用于与数据库进行通信的计算机语言。

SQL 结构：做什么，从哪里，怎么做

1、如何使用SQL检索数据？

思路：检索数据要用到select 关键字，功能是从一张表或者多张表中检索信息。

select 列名   // 需要选的列名称

from 表名/列名 // 从哪里选择

排序选择： select * from user order by age DESC //根据年龄降序排列。

select * from user where age > 20 ORDER BY age DESC；

**A：** 基本语法：

```
SELECT <列名>
FROM <表名/视图>
WHERE <筛选条件>
ORDER BY <列名> <ASC/ DESC>
```

?Q：

JDBC 连接和使用MySQL 数据库，遵循JDBC 标准的API 使用方式，与其他数据库的区别主要在于驱动文件和URL的不同。

**执行的步骤：加载驱动，获得连接，创建会话，就可以执行操作了。执行操作结束后需执行关闭连接。**

数据库分页查询。Limit 3 offset 2; 或者采用limit 2, 3;

PQ: 数据库的存储过程怎么写

PQ: 数据库SQL优化？

Q: 索引有利有弊，怎么看？

事务的四大特性： ACID

**原子性，一致性，隔离性，持久性**



**事务隔离级别：**

1、读取未提交的数据（会出现脏读、不可重复读）

2、读已提交的数据（会出现不可重复读和幻读）

3、可重复读（会出现幻读）

4、串行化

拓展问题： 考虑事务的隔离级别的出发点考虑到是否为



### 数据交互知识(JSON、XML)：

#### XML解析方式： 

dom树解析和sax 解析有什么区别？

DOM: 处理大型文件时其性能下降的非常厉害。这个问题是由Dom 树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档加载到内存里面，适合对XML进行随机访问的需求。SAX 解析是基于事件驱动型的XML解析方式，顺序读取XML文件，不需要一次性加载整个XML文件，当遇到像文件开头，文档结束，或者标签开头和标签结束时，它会触发一次事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML文件的顺序访问。



数据库优化知识：

#### SpringAOP,IoC实现原理

AOP实现原理、动态代理和静态代理、Spring IoC的初始化过程、IoC原理、自己实现怎么实现一个IoC容器？这些东西都是经常会被问到的。

简单的IoC容器：

1、加载XML 配置文件，遍历其中的标签。

2、获取

3、填充到bean 中

4、注册到bean 容器（Spring）



**Q: 理解说下Spring的IoC ：**

自己去创建对象实例，交由Spring 框架帮我们实例化。也就是说，之前有程序员去考虑对象实例的生命周期，现在让框架去帮我们实现，去帮我们管理对象的生命周期。

**Q: 说下DI依赖注入的理解:**

某个Bean(实例)里面维护了另外一个Bean的引用，称之这个bean 依赖于另外一个bean。

理解：现在有一个请求发送到Controller层，Controller层需要调用service 对象的方法，而Service 有需要调用dao的方法，那么其实在创建controller对象时，就应该吧service兑现注入响应请求方法里面，service对象创建时有需要把dao对象注入到service。

Q: SpringMVC 接收URL是如何映射到方法上的？

Q：Spring有哪些模块？（应该问的是Spring的架构）

Q: Spring 涉及的设计模式

1、简单工厂模式、工厂模式、抽象工厂模式的区别？

简单工厂模式（静态工厂模式）: 简单工厂是一个类其中一个静态方法，根据传入的参数来指定生成对象。

工厂模式：工厂模式提供了一个抽象的工厂类，该类有一个生产抽象产品的接口，程序员可根据需要继承抽象工厂实现生产特定产品的方法，并且自己实现特定的产品。工厂模式关注点在

Q: 说说IOC(控制反转)，为什么要使用控制反转？



#### Springboot 

简介： 用来简化Spring 应用的初始化搭建以及开发过程，使用特定的方式来进行配置（properties或者yaml文件），创建独立的Spring 引用程序，采用main方法运行，内嵌tomcat，无需部署war文件，简化maven配置。

Q: 如何将Spring boot的配置文件放在jar 外部。

A: 可以采用通过命令行传参的方式来指定 Spring.config.locaion 的位置，这个要写全路径。

通过注解的方式， `@PropertySource`

#### MyBatis：

Q: MyBatis 是如何插入对象的？

#### Hibernate：

Q: Hibernate的查询有几种方式？





问题：**Hibernate 和 MyBatis区别，两者的使用场景，两者的优缺点**

> hibernate 完全可以通过**对象关系模型**实现对数据库的操作，拥有完整的javabean对象与数据库的映射结构来自动生成sql。而Mybatis 仅有基本的字段映射，对象数组以及对象实际关系仍然需要通过**手写sql 来实现和管理**。
> **Hibernate 的移植性远远大于MyBatis。**
> Hibernate 通过它强大的映射结构和hql 语言，大大降低了对象与数据的耦合性，也就是说采取什么数据库都不重要，而Mybatis 由于要手写SQL语句，因而对于数据库的耦合性取决于程序员手写sql 的方式，若是sql 不具备通用性而用某种数据库特有的sql语句，移植性将会大打折扣，维护成本增高。
> Hibernate 拥有完整的日志系统，Mybatis 则欠缺一些。
> Hibernate日志系统非常健全，涉及广泛，包括对sql 记录、关系异常、优化警告、缓存提示、脏数据警告等；而Mybatis则只是具备基本记录功能，功能相对单薄一些。

简述：Mybatis和Hibernate的区别

1、Mybatis是一个不完全的ORM框架，因为mybatis需要开发者自己写大量的sql语句，不过Mybatis可以通过XML文件可以灵活的配置要运行的sql语句，将sql语句与Java 对象做了很好的映射。

2、Mybatis 的学习成本相对于Hibernate 比较低，可以严格控制SQL语句的执行性能，灵活度高，适合于对关系数据模型要求不高的软件开发，比如互联网软件，企业运营类软件等。因为这类软件的需求变化块而且多。灵活的前提是无法做到数据库的无关系，若是要实现支持多种数据库的软件则要自定义多套sql映射文件，开发工作量大。

3、Hibernate 是一套完成的ORM框架，数据库无关性好，使用与关系数据模型较高的软件，可以节省很多代码，提高工作效率。且Hibernate的性能调优需要很强的经验和能力。总之，用户需求在有限的资源环境下只要做出易于维护，扩展性好的软件架构都是好架构。



**Struts2的问题：**

Q1: 为什么每次请求都要创建一个Action 对象？

用于保证线程安全。

Q2: ModelDriven 拦截器的配置中refreshModelBeforeResult 解决了什么问题。

在数据输出之前将数据接收的bean里面的数据清空。解决了数据混淆的可能性。

Q3: 为什么在web.xml中配置的StrutsPrepareAndExecuteFilter 要过滤所有请求？

可以对数据进行过滤，可以将数据的编码统一。



###  其他技术

#### **Redis**

1、Redis 有哪些数据结构？

字符串String、字典Hash、列表List、集合Set、有序集合SortedSet

高级数据结构：HyperLog： 基于统计

GEO: 地理位置

PUB/SUB: 订阅发布

2、Redis 是单进程单线程的吗？

是的。Redis 是基于内存的单进程单线程KV数据库，基于C语言编写。其性能良好，是完全基于内存。

数据结构简单、对数据的操作也比较简单。使用多路复用I/O模型（多个网络连接复用同一个线程）。

3、假如Redis 里面有1亿个key,其中有10W个key 是以某个固定的已知的前缀开头，若是将它们全部找出来？

采用keys+正则的方式，会阻塞服务器。 scan+模糊查询。不会阻塞服务器。

4、Redis 如何做持久化？



5、Redis的同步机制：



Q： redis的应用场景

会话缓存（session cache） 全页缓存（FPC）、队列、排行版、发布/订阅。

Q: Redis 的持久化

Redis DataBase（RDB）: 该机制可以在指定的时间间隔内生成数据集的时间快照（point-in-time snapshot）

AOF（append-only-file) 持久化： 记录服务器执行的所有写的操作命令，并在服务器重启时，通过重新执行这些命令来还原数据库，AOF





### 并发问题：

Q: 如何处理高并发问题？

一般采用页面静态化，集群分布式，反向代理、负载均衡 等手段。

### 项目问题：

三个项目的介绍：

Q: 实现点赞点踩功能采用Redis 和异步消息队列， 如何实现的呢？

建表，然后就

根据需求确定了key 字段， 格式是 like: 实体类型： 实体id 和 dislike: 实体类型：实体id。

将喜欢新闻的人存在一个集合里，不喜欢的这一条新闻存在另外一个集合里。通过计算个数来获得点赞和点踩的个数。一般点赞点踩操作是先修改redis的值并获取返回值，然后在异步修改mysql数据库的likecount值。这样既可以保证点赞点踩操作快速完成，也可以保证数据的一致性。



消息队列发送消息失败的处理？ 重发咯

ActiveMQ中的**消息重发时间间隔**和**重发次数**

对于重发次数，设置-1的话就是不限制重发次数，默认设置的话。好像是6个重发次数.





### 软件工程知识：

开发中涉及到技术文档：



软件流程图：



### Linux：

Q: 说说linux 常见命令，经常用到的哪些？（2min）

对于文件操作，我常用有 pwd 显示当前所在路径、mkdir filename 创建文件夹、mkdir-p 创建嵌套的目录，touch 新建一个文件、cp oldfile newfile 复制、mv 移动或者复制命令 rm 删除

rm -rf 强制删除目录或者文件夹。rmdir 删除文件夹（只能删除空的）

对文件内容：查看文件内容用cat的吧， 

vi命令 进行编辑，有三种模式，**插入模式，命令模式和末行模式**，我比较用得多是命令模式和编辑模式。我喜欢按i键进入插入模式，保存修改后，按esc 键，输入：wq! 保存和退出。一般我都用于进行对服务器上的xml 文件进行修改。

日常维护：

1、查看的服务器对应的进程用 **ps -ef|grep “tomcat”**， 可以查看服务器所对应的进程，以及服务器安装的目录。

2、关闭服务器可以空kill -9 pid （指定的进程id）来杀死进程。也可以到tomcat安装目录下的bin目录下执行shutdown.sh。

3. 使用**winscp** 来上传修改后的文件。
4. putty远程控制linux 服务器。
5. 用tail -f  行数 命令查看日志。

linux 命令比较多，现在只能想这么多，一些不太熟的命令，我都会整理在文档上的，方便以后自己查找。

Q：Linux 如何开启防火墙



改变文件权限： chomd

改变文件所有者 chown



**面试题总结：**

【Q1、如何判断一个数是否在40亿整数中】

A: 若是直接用map的方式的话，那么需要的存储的空间大，且不利于查找。

将所有整数存放在一个set 集合里面。 若是考虑整数为32位的话，一个整数为4字节，40亿个，就得160亿字节，大约得16GB

1024*1024 = 1000 000 = 100万

**思路一：**采用分布式的方式，由于16GB 数据用2GB的内分8次加载，这样加载的速度太慢了，设置一个集群的方式，分布在8台机子上，然后加载完毕后， 一次性读取，分别在8台机子里面找，这样就快多了。

**思路二：**判断一个数是否存在，只有两种状态， 1或者 0， 1 表示该数存在，0表示该数不存在。

那么久申请40 位的字节数组，大概需要40亿位的数组。这样需要思考一个问题，一个整数的范围是2的32次方，大概范围是42亿多。可以考虑申请一个2的32方位的字节数组。根据位数来存放整数，若是这个数是1024的话，对应的数组位置应该为1024 为第1024位的，若是存在，这个位置的数应该为1，不存在应该为0。 2^32个位，相当于2的29次方字节，大约500MB。

**BitMap 算法：**

利用位图， 利用位来表示状态，从而节省空间。

**思路三：** 考虑到40亿的整数可能存在连续的，32位int的范围是42亿，40亿整数需要先进行一次外部排序，然后用一个初始的数和一个长度构成一个数据结构，来表示一段连续的数，例如，若是数据为1,2,3,4, 6,7...的情况,可以利用(1,4)、 (6,2)来表示，这样一来，连续的数都变成2个整数表示，若是来了一个新数的话，采用2分查找的方式，这样最差的case也就是2亿多个断点， 需要构建2亿多个结构体，每个结构体8个字节，大概就是16亿字节，1.6GB。

